(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[63],{1681:function(module,exports,__webpack_require__){module.exports={rules:{"typescript/adjacent-overload-signatures":__webpack_require__(1682),"typescript/class-name-casing":__webpack_require__(1683),"typescript/explicit-function-return-type":__webpack_require__(1685),"typescript/explicit-member-accessibility":__webpack_require__(1686),"typescript/interface-name-prefix":__webpack_require__(1687),"typescript/member-delimiter-style":__webpack_require__(1688),"typescript/member-naming":__webpack_require__(1689),"typescript/member-ordering":__webpack_require__(1690),"typescript/no-angle-bracket-type-assertion":__webpack_require__(1691),"typescript/no-array-constructor":__webpack_require__(1692),"typescript/no-empty-interface":__webpack_require__(1693),"typescript/no-explicit-any":__webpack_require__(1694),"typescript/no-inferrable-types":__webpack_require__(1695),"typescript/no-namespace":__webpack_require__(1696),"typescript/no-non-null-assertion":__webpack_require__(1697),"typescript/no-parameter-properties":__webpack_require__(1698),"typescript/no-triple-slash-reference":__webpack_require__(1699),"typescript/no-type-alias":__webpack_require__(1700),"typescript/no-unused-vars":__webpack_require__(1701),"typescript/no-use-before-define":__webpack_require__(1702),"typescript/no-var-requires":__webpack_require__(1703),"typescript/prefer-namespace-keyword":__webpack_require__(1704),"typescript/type-annotation-spacing":__webpack_require__(1705)}}},1682:function(module,exports,__webpack_require__){"use strict";module.exports={meta:{docs:{description:"Require that member overloads be consecutive",category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/adjacent-overload-signatures.md"},schema:[]},create(context){function getMemberName(member){if(!member)return null;switch(member.type){case"ExportDefaultDeclaration":case"ExportNamedDeclaration":{return member.declaration?getMemberName(member.declaration):null}case"DeclareFunction":case"FunctionDeclaration":case"TSNamespaceFunctionDeclaration":{return member.id.name}case"TSMethodSignature":{return member.key&&(member.key.name||member.key.value)||member.name&&(member.name.name||member.name.value)}case"TSCallSignature":{return"call"}case"TSConstructSignature":{return"new"}case"MethodDefinition":{return member.key.name||member.key.value}default:{return null}}}function checkBodyForOverloadMethods(node){const members=node.body||node.members;if(members){let name;let index;let lastName;const seen=[];members.forEach(member=>{name=getMemberName(member);index=seen.indexOf(name);if(index>-1&&lastName!==name){context.report({node:member,message:`All '${name}' signatures should be adjacent`})}else if(name&&index===-1){seen.push(name)}lastName=name})}}return{TSModuleBlock:checkBodyForOverloadMethods,TSTypeLiteral:checkBodyForOverloadMethods,TSInterfaceBody:checkBodyForOverloadMethods,ClassBody:checkBodyForOverloadMethods,Program:checkBodyForOverloadMethods}}}},1683:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Require PascalCased class and interface names",extraDescription:[util.tslintRule("class-name")],category:"Best Practices",recommended:true,url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/class-name-casing.md"}},create(context){function isPascalCase(name){return/^[A-Z][0-9A-Za-z]*$/.test(name)}function report(decl,id){id=id||decl.id;let friendlyName;switch(decl.type){case"ClassDeclaration":case"ClassExpression":friendlyName="Class";break;case"TSInterfaceDeclaration":friendlyName="Interface";break;default:friendlyName=decl.type}context.report({node:id,message:`${friendlyName} '${id.name}' must be PascalCased`})}return{"ClassDeclaration, TSInterfaceDeclaration"(node){if(node.id&&!isPascalCase(node.id.name)){report(node)}},VariableDeclarator(node){if(node.init&&node.init.type==="ClassExpression"){const id=node.id;if(node.init.id&&!isPascalCase(node.init.id.name)){report(node.init)}else if(id&&!isPascalCase(id.name)){report(node.init,id)}}}}}}},1684:function(module,exports,__webpack_require__){"use strict";exports.tslintRule=(name=>`\`${name}\` from TSLint`);exports.isTypescript=(fileName=>/\.tsx?$/.test(fileName))},1685:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Require explicit return types on functions and class methods",category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/explicit-function-return-type.md"},schema:[{type:"object",properties:{allowExpressions:{type:"boolean"}},additionalProperties:false}]},create(context){const options=context.options[0]||{};function isConstructor(parent){return parent.type==="MethodDefinition"&&parent.kind==="constructor"}function isSetter(parent){return parent.type==="MethodDefinition"&&parent.kind==="set"}function checkFunctionReturnType(node){if(options.allowExpressions&&node.type!=="FunctionDeclaration"&&node.parent.type!=="VariableDeclarator"){return}if(!node.returnType&&!isConstructor(node.parent)&&!isSetter(node.parent)&&util.isTypescript(context.getFilename())){context.report({node,message:`Missing return type on function.`})}}return{FunctionDeclaration:checkFunctionReturnType,FunctionExpression:checkFunctionReturnType,ArrowFunctionExpression:checkFunctionReturnType}}}},1686:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Require explicit accessibility modifiers on class properties and methods",extraDescription:[util.tslintRule("member-access")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/explicit-member-accessibility.md"},schema:[]},create(context){function checkMethodAccessibilityModifier(methodDefinition){if(!methodDefinition.accessibility&&util.isTypescript(context.getFilename())){context.report({node:methodDefinition,message:`Missing accessibility modifier on method definition ${methodDefinition.key.name}.`})}}function checkPropertyAccessibilityModifier(classProperty){if(!classProperty.accessibility&&util.isTypescript(context.getFilename())){context.report({node:classProperty,message:`Missing accessibility modifier on class property ${classProperty.key.name}.`})}}return{ClassProperty:checkPropertyAccessibilityModifier,MethodDefinition:checkMethodAccessibilityModifier}}}},1687:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Require that interface names be prefixed with `I`",extraDescription:[util.tslintRule("interface-name")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/interface-name-prefix.md"},schema:[{enum:["never","always"]}]},create(context){const never=context.options[0]!=="always";function isPrefixedWithI(name){if(typeof name!=="string"){return false}if(name.length===0){return false}const first=name.charAt(0);const second=name.charAt(1);if(second===""){return false}if(first!=="I"||second!==second.toUpperCase()){return false}return true}function checkInterfacePrefix(interfaceNode){if(never){if(isPrefixedWithI(interfaceNode.id.name)){context.report({node:interfaceNode.id,message:'Interface name must not be prefixed with "I"'})}}else{if(!isPrefixedWithI(interfaceNode.id.name)){context.report({node:interfaceNode.id,message:'Interface name must be prefixed with "I"'})}}}return{TSInterfaceDeclaration:checkInterfacePrefix}}}},1688:function(module,exports,__webpack_require__){"use strict";const definition={type:"object",properties:{delimiter:{enum:["none","semi","comma"]},requireLast:{type:"boolean"},ignoreSingleLine:{type:"boolean"}},additionalProperties:false};module.exports={meta:{docs:{description:"Require a specific member delimiter style for interfaces and type literals",category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/member-delimiter-style.md"},fixable:"code",schema:[{type:"object",properties:{delimiter:{enum:["none","semi","comma"]},requireLast:{type:"boolean"},ignoreSingleLine:{type:"boolean"},overrides:{type:"object",properties:{interface:definition,typeLiteral:definition},additionalProperties:false}},additionalProperties:false}]},create(context){const sourceCode=context.getSourceCode();const options=context.options[0]||{};const overrides=options.overrides||{};const defaults={delimiter:"semi",requireLast:true,ignoreSingleLine:true};const interfaceOptions=Object.assign({},defaults,options,overrides.interface);const typeLiteralOptions=Object.assign({},defaults,options,overrides.typeLiteral);function checkLastToken(member,opts,isLast,isSameLine){let message;let missingDelimiter=false;const lastToken=sourceCode.getLastToken(member,{includeComments:false});if(lastToken.value===";"&&opts.delimiter!=="semi"){message=opts.delimiter==="comma"?"Expected a comma.":"Unexpected separator (;)."}else if(lastToken.value===","&&opts.delimiter!=="comma"){message=opts.delimiter==="semi"?"Expected a semicolon.":"Unexpected separator (,)."}else if(lastToken.value!==";"&&lastToken.value!==","&&opts.delimiter!=="none"){let canOmit=isLast;if(canOmit){canOmit=!opts.requireLast||isSameLine&&opts.ignoreSingleLine}if(!canOmit){missingDelimiter=true;message=opts.delimiter==="semi"?"Expected a semicolon.":"Expected a comma."}}if(message){context.report({node:lastToken,loc:{start:{line:lastToken.loc.end.line,column:lastToken.loc.end.column},end:{line:lastToken.loc.end.line,column:lastToken.loc.end.column}},message,fix(fixer){let token;if(opts.delimiter==="semi"){token=";"}else if(opts.delimiter==="comma"){token=","}else{return fixer.remove(lastToken)}if(missingDelimiter){return fixer.insertTextAfter(lastToken,token)}else if(isLast&&!opts.requireLast){return fixer.remove(lastToken)}return fixer.replaceText(lastToken,token)}})}}function checkMemberSeparatorStyle(node){const isSingleLine=node.loc.start.line===node.loc.end.line;const isInterface=node.type==="TSInterfaceBody";const members=isInterface?node.body:node.members;members.forEach((member,index)=>{checkLastToken(member,isInterface?interfaceOptions:typeLiteralOptions,index===members.length-1,isSingleLine)})}return{TSInterfaceBody:checkMemberSeparatorStyle,TSTypeLiteral:checkMemberSeparatorStyle}}}},1689:function(module,exports,__webpack_require__){"use strict";module.exports={meta:{docs:{description:"Enforces naming conventions for class members by visibility.",category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/member-naming.md"},schema:[{type:"object",properties:{public:{type:"string"},protected:{type:"string"},private:{type:"string"}},additionalProperties:false}]},create(context){const config=context.options[0]||{};const conventions={};for(const accessibility of Object.getOwnPropertyNames(config)){conventions[accessibility]=new RegExp(config[accessibility])}function validateName(node){const name=node.key.name;const accessibility=node.accessibility||"public";const convention=conventions[accessibility];if(!convention||convention.test(name))return;context.report({node:node.key,message:"{{accessibility}} property {{name}} should match {{convention}}",data:{accessibility,name,convention}})}return{MethodDefinition:validateName,ClassProperty:validateName}}}},1690:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);const schemaOptions=["field","method","constructor"].reduce((options,type)=>{options.push(type);["public","protected","private"].forEach(accessibility=>{options.push(`${accessibility}-${type}`);if(type!=="constructor"){["static","instance"].forEach(scope=>{if(options.indexOf(`${scope}-${type}`)===-1){options.push(`${scope}-${type}`)}options.push(`${accessibility}-${scope}-${type}`)})}});return options},[]);module.exports={meta:{docs:{description:"Require a consistent member declaration order",extraDescription:[util.tslintRule("member-ordering")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/member-ordering.md"},schema:[{type:"object",properties:{default:{oneOf:[{enum:["never"]},{type:"array",items:{enum:schemaOptions}}]},classes:{oneOf:[{enum:["never"]},{type:"array",items:{enum:schemaOptions}}]},classExpressions:{oneOf:[{enum:["never"]},{type:"array",items:{enum:schemaOptions}}]},interfaces:{oneOf:[{enum:["never"]},{type:"array",items:{enum:["field","method","constructor"]}}]},typeLiterals:{oneOf:[{enum:["never"]},{type:"array",items:{enum:["field","method","constructor"]}}]}},additionalProperties:false}]},create(context){const options=context.options[0]||{};const functionExpressions=["FunctionExpression","ArrowFunctionExpression"];const defaultOrder=["public-static-field","protected-static-field","private-static-field","public-instance-field","protected-instance-field","private-instance-field","public-field","protected-field","private-field","static-field","instance-field","field","constructor","public-static-method","protected-static-method","private-static-method","public-instance-method","protected-instance-method","private-instance-method","public-method","protected-method","private-method","static-method","instance-method","method"];function shouldBeProcessedAsMethod(node){return node.value&&functionExpressions.indexOf(node.value.type)>-1}function getNodeType(node){switch(node.type){case"MethodDefinition":return node.kind;case"TSMethodSignature":return"method";case"TSConstructSignature":return"constructor";case"ClassProperty":case"TSPropertySignature":return shouldBeProcessedAsMethod(node)?"method":"field";default:return null}}function getMemberName(node){switch(node.type){case"ClassProperty":case"MethodDefinition":return node.kind==="constructor"?"constructor":node.key.name;case"TSPropertySignature":case"TSMethodSignature":return node.key.name;case"TSConstructSignature":return"new";default:return null}}function getRankOrder(names,order){let rank=-1;const stack=names.slice();while(stack.length>0&&rank===-1){rank=order.indexOf(stack.shift())}return rank}function getRank(node,order,supportsModifiers){const type=getNodeType(node);const scope=node.static?"static":"instance";const accessibility=node.accessibility||"public";const names=[];if(supportsModifiers){if(type!=="constructor"){names.push(`${accessibility}-${scope}-${type}`);names.push(`${scope}-${type}`)}names.push(`${accessibility}-${type}`)}names.push(type);return getRankOrder(names,order)}function getLowestRank(ranks,target,order){let lowest=ranks[ranks.length-1];ranks.forEach(rank=>{if(rank>target){lowest=Math.min(lowest,rank)}});return order[lowest].replace(/-/g," ")}function validateMembers(members,order,supportsModifiers){if(members&&order!=="never"){const previousRanks=[];members.forEach(member=>{const rank=getRank(member,order,supportsModifiers);if(rank!==-1){if(rank<previousRanks[previousRanks.length-1]){context.report({node:member,message:"Member {{name}} should be declared before all {{rank}} definitions.",data:{name:getMemberName(member),rank:getLowestRank(previousRanks,rank,order)}})}else{previousRanks.push(rank)}}})}}return{ClassDeclaration(node){validateMembers(node.body.body,options.classes||options.default||defaultOrder,true)},ClassExpression(node){validateMembers(node.body.body,options.classExpressions||options.default||defaultOrder,true)},TSInterfaceDeclaration(node){validateMembers(node.body.body,options.interfaces||options.default||defaultOrder,false)},TSTypeLiteral(node){validateMembers(node.members,options.typeLiterals||options.default||defaultOrder,false)}}}}},1691:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Enforces the use of `as Type` assertions instead of `<Type>` assertions",extraDescription:[util.tslintRule("no-angle-bracket-type-assertion")],category:"Style",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-angle-bracket-type-assertion.md"},schema:[]},create(context){const sourceCode=context.getSourceCode();return{TSTypeAssertionExpression(node){context.report({node,message:"Prefer 'as {{cast}}' instead of '<{{cast}}>' when doing type assertions",data:{cast:sourceCode.getText(node.typeAnnotation.typeAnnotation)}})}}}}},1692:function(module,exports,__webpack_require__){"use strict";module.exports={meta:{docs:{description:"Disallow generic `Array` constructors",category:"Stylistic Issues",recommended:false,url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-array-constructor.md"},fixable:"code",schema:[]},create(context){function check(node){if(node.arguments.length!==1&&node.callee.type==="Identifier"&&node.callee.name==="Array"&&!node.typeParameters){context.report({node,message:"The array literal notation [] is preferrable.",fix(fixer){if(node.arguments.length===0){return fixer.replaceText(node,"[]")}const fullText=context.getSourceCode().getText(node);const preambleLength=node.callee.range[1]-node.range[0];return fixer.replaceText(node,`[${fullText.slice(preambleLength+1,-1)}]`)}})}}return{CallExpression:check,NewExpression:check}}}},1693:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Disallow the declaration of empty interfaces",extraDescription:[util.tslintRule("no-empty-interface")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-empty-interface.md"},schema:[]},create(context){return{TSInterfaceDeclaration(node){const heritage=node.heritage.length;if(node.body.body.length===0&&heritage<2){context.report({node:node.id,message:heritage===0?"An empty interface is equivalent to `{}`":"An interface declaring no members is equivalent to its supertype."})}}}}}},1694:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Disallow usage of the `any` type",extraDescription:[util.tslintRule("no-any")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-explicit-any.md"},schema:[]},create(context){function checkGenericNodeForAnnotation(node){if(node.type==="TSAnyKeyword"){context.report({node,message:"Unexpected any. Specify a different type."})}else if(node.type==="TSArrayType"){checkGenericNodeForAnnotation(node.elementType)}else if(node.type==="TSUnionType"||node.type==="TSIntersectionType"){node.types.forEach(type=>{checkGenericNodeForAnnotation(type)})}else if(node.type==="TSTypeReference"){if(node.typeParameters){node.typeParameters.params.forEach(param=>{checkGenericNodeForAnnotation(param)})}else if(node.typeName){checkGenericNodeForAnnotation(node.typeName)}}else if(node.type==="GenericTypeAnnotation"){if(node.typeParameters){node.typeParameters.params.forEach(param=>{checkGenericNodeForAnnotation(param)})}else{checkGenericNodeForAnnotation(node.id)}}}function checkFunctionReturnTypeForAnnotation(node){if(node.returnType){checkGenericNodeForAnnotation(node.returnType.typeAnnotation)}}return{Identifier(node){if(node.typeAnnotation){checkGenericNodeForAnnotation(node.typeAnnotation.typeAnnotation)}},TSTypeAnnotation(node){if(node.typeAnnotation){checkGenericNodeForAnnotation(node.typeAnnotation)}},FunctionDeclaration:checkFunctionReturnTypeForAnnotation,FunctionExpression:checkFunctionReturnTypeForAnnotation,ArrowFunctionExpression:checkFunctionReturnTypeForAnnotation}}}},1695:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Disallows explicit type declarations for variables or parameters initialized to a number, string, or boolean.",extraDescription:[util.tslintRule("no-inferrable-types")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-inferrable-types.md"},fixable:"code",schema:[{type:"object",properties:{ignoreParameters:{type:"boolean"},ignoreProperties:{type:"boolean"}},additionalProperties:false}]},create(context){const ignoreParameters=context.options[0]?context.options[0].ignoreParameters:false;const ignoreProperties=context.options[0]?context.options[0].ignoreProperties:false;function isInferrable(node,init){if(node.type!=="TSTypeAnnotation"||!node.typeAnnotation){return false}if(!init){return false}const annotation=node.typeAnnotation;if(annotation.type==="TSStringKeyword"){return init.type==="Literal"&&typeof init.value==="string"||init.type==="TemplateElement"&&(!init.expressions||init.expressions.length===0)}if(annotation.type==="TSBooleanKeyword"){return init.type==="Literal"}if(annotation.type==="TSNumberKeyword"){if(init.type==="UnaryExpression"&&init.operator==="-"&&init.argument.type==="Identifier"&&init.argument.name==="Infinity"||init.type==="Identifier"&&init.name==="Infinity"){return true}return init.type==="Literal"&&typeof init.value==="number"}return false}function reportInferrableType(node,typeNode,initNode){if(!typeNode||!initNode||!typeNode.typeAnnotation){return}if(!isInferrable(typeNode,initNode)){return}const typeMap={TSBooleanKeyword:"boolean",TSNumberKeyword:"number",TSStringKeyword:"string"};const type=typeMap[typeNode.typeAnnotation.type];context.report({node,message:`Type ${type} trivially inferred from a ${type} literal, remove type annotation`,fix:fixer=>fixer.remove(typeNode)})}function inferrableVariableVisitor(node){if(!node.id){return}reportInferrableType(node,node.id.typeAnnotation,node.init)}function inferrableParameterVisitor(node){if(ignoreParameters||!node.params){return}node.params.filter(param=>param.type==="AssignmentPattern"&&param.left&&param.right).forEach(param=>{reportInferrableType(param,param.left.typeAnnotation,param.right)})}function inferrablePropertyVisitor(node){if(ignoreProperties||node.readonly){return}reportInferrableType(node,node.typeAnnotation,node.value)}return{VariableDeclarator:inferrableVariableVisitor,FunctionExpression:inferrableParameterVisitor,FunctionDeclaration:inferrableParameterVisitor,ArrowFunctionExpression:inferrableParameterVisitor,ClassProperty:inferrablePropertyVisitor}}}},1696:function(module,exports,__webpack_require__){"use strict";module.exports={meta:{docs:{description:"Disallow the use of custom TypeScript modules and namespaces",category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-namespace.md"},schema:[{type:"object",properties:{allowDeclarations:{type:"boolean"},allowDefinitionFiles:{type:"boolean"}},additionalProperties:false}]},create(context){const allowDeclarations=context.options[0]?context.options[0].allowDeclarations:false;const allowDefinitionFiles=context.options[0]?context.options[0].allowDefinitionFiles:false;function isTypeScriptModuleDeclaration(node){return node.id&&node.id.type==="Literal"}function isDeclaration(node){return node.declare===true&&!isTypeScriptModuleDeclaration(node)}function isDefinitionFile(){const filename=context.getFilename();return filename?filename.slice(-5).toLowerCase()===".d.ts":false}return{TSModuleDeclaration(node){if(isTypeScriptModuleDeclaration(node)||allowDefinitionFiles&&isDefinitionFile()||allowDeclarations&&isDeclaration(node)){return}context.report({node,message:"ES2015 module syntax is preferred over custom TypeScript modules and namespaces"})}}}}},1697:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Disallows non-null assertions using the `!` postfix operator",extraDescription:[util.tslintRule("no-non-null-assertion")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-non-null-assertion.md"},schema:[]},create(context){return{TSNonNullExpression(node){context.report({node,message:"Forbidden non-null assertion"})}}}}},1698:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Disallow the use of parameter properties in class constructors.",extraDescription:[util.tslintRule("no-parameter-properties")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-parameter-properties.md"},schema:[{type:"object",properties:{allows:{type:"array",items:{enum:["readonly","private","protected","public","private readonly","protected readonly","public readonly"]},minItems:1}},additionalProperties:false}]},create(context){const options=context.options[0]||{};const allows=options.allows||[];function getModifiers(node){const modifiers=[];modifiers.push(node.accessibility);if(node.readonly||node.isReadonly){modifiers.push("readonly")}return modifiers.filter(Boolean).join(" ")}return{TSParameterProperty(node){const modifiers=getModifiers(node);if(allows.indexOf(modifiers)===-1){context.report({node,message:"Property {{parameter}} cannot be declared in the constructor",data:{parameter:node.parameter.name}})}}}}}},1699:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:'Disallow `/// <reference path="" />` comments',extraDescription:[util.tslintRule("no-reference")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-triple-slash-reference.md"},schema:[]},create(context){const referenceRegExp=/^\/\s*<reference/;const sourceCode=context.getSourceCode();function checkTripleSlashReference(program){const commentsBefore=sourceCode.getCommentsBefore(program);commentsBefore.forEach(comment=>{if(comment.type!=="Line"){return}if(referenceRegExp.test(comment.value)){context.report({node:comment,message:"Do not use a triple slash reference"})}})}return{Program:checkTripleSlashReference}}}},1700:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Disallow the use of type aliases",extraDescription:[util.tslintRule("interface-over-type-literal")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-type-alias.md"},schema:[{type:"object",properties:{allowAliases:{enum:[true,false,"always","never","in-unions","in-intersections","in-unions-and-intersections"]},allowCallbacks:{enum:[true,false,"always","never"]},allowLiterals:{enum:[true,false,"always","never","in-unions","in-intersections","in-unions-and-intersections"]},allowMappedTypes:{enum:[true,false,"always","never","in-unions","in-intersections","in-unions-and-intersections"]}},additionalProperties:false}]},create(context){const options=context.options[0];const allowAliases=options&&options.allowAliases||"never";const allowCallbacks=options&&options.allowCallbacks||"never";const allowLiterals=options&&options.allowLiterals||"never";const allowMappedTypes=options&&options.allowMappedTypes||"never";const unions=[true,"always","in-unions","in-unions-and-intersections"];const intersections=[true,"always","in-intersections","in-unions-and-intersections"];const compositions=["in-unions","in-intersections","in-unions-and-intersections"];const aliasTypes=["TSLastTypeNode","TSArrayType","TSTypeReference"];function isComposition(node){return node&&(node.type==="TSUnionType"||node.type==="TSIntersectionType")}function isSupportedComposition(isTopLevel,compositionType,allowed){return compositions.indexOf(allowed)===-1||!isTopLevel&&(compositionType==="TSUnionType"&&unions.indexOf(allowed)>-1||compositionType==="TSIntersectionType"&&intersections.indexOf(allowed)>-1)}function isAlias(node){return node&&(/Keyword$/.test(node.type)||aliasTypes.indexOf(node.type)>-1)}function isCallback(node){return node&&node.type==="TSFunctionType"}function isLiteral(node){return node&&node.type==="TSTypeLiteral"}function isMappedType(node){return node&&node.type==="TSMappedType"}function getMessage(compositionType,isRoot,type){if(isRoot){return type?`Type ${type} are not allowed`:"Type aliases are not allowed"}return compositionType==="TSUnionType"?`${type[0].toUpperCase()}${type.substring(1)} in union types are not allowed`:`${type[0].toUpperCase()}${type.substring(1)} in intersection types are not allowed`}function validateTypeAliases(node,isTopLevel,compositionType){if(isAlias(node)){if(allowAliases==="never"||!isSupportedComposition(isTopLevel,compositionType,allowAliases)){context.report({node,message:getMessage(compositionType,isTopLevel,"aliases")})}}else if(isCallback(node)){if(allowCallbacks==="never"){context.report({node,message:getMessage(compositionType,isTopLevel,"callbacks")})}}else if(isLiteral(node)){if(allowLiterals==="never"||!isSupportedComposition(isTopLevel,compositionType,allowLiterals)){context.report({node,message:getMessage(compositionType,isTopLevel,"literals")})}}else if(isMappedType(node)){if(allowMappedTypes==="never"||!isSupportedComposition(isTopLevel,compositionType,allowMappedTypes)){context.report({node,message:getMessage(compositionType,isTopLevel,"mapped types")})}}else{context.report({node,message:getMessage(compositionType,isTopLevel)})}}function validateCompositions(node){node.types.forEach(type=>{if(isComposition(type)){validateCompositions(type)}else{validateTypeAliases(type,false,node.type)}})}function validateNode(node,isTopLevel){if(isComposition(node)){validateCompositions(node)}else{validateTypeAliases(node,isTopLevel)}}return{VariableDeclaration(node){if(node.kind==="type"){validateNode(node.declarations[0].init,true)}}}}}},1701:function(module,exports,__webpack_require__){"use strict";function markVariableAsUsed(context,name){let scope=context.getScope();let variables;let i;let len;let found=false;if(scope.type==="global"){while(scope.childScopes.length){scope=scope.childScopes[0]}}do{variables=scope.variables;for(i=0,len=variables.length;i<len;i++){if(variables[i].name===name){variables[i].eslintUsed=true;found=true}}scope=scope.upper}while(scope);return found}module.exports={meta:{docs:{description:"Prevent TypeScript-specific constructs from being erroneously flagged as unused",category:"TypeScript",recommended:true,url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-unused-vars.md"},schema:[]},create(context){function markTypeAnnotationAsUsed(node){const annotation=node.typeAnnotation||node;switch(annotation.type){case"Identifier":{markVariableAsUsed(context,annotation.name);break}case"TSArrayType":{markTypeAnnotationAsUsed(annotation.elementType);break}case"TSQualifiedName":{markTypeAnnotationAsUsed(annotation.left);markTypeAnnotationAsUsed(annotation.right);break}case"TSTypeReference":{if(annotation.typeName.type==="TSArrayType"){markTypeAnnotationAsUsed(annotation.typeName.elementType)}else if(annotation.typeName.type==="TSQualifiedName"){markTypeAnnotationAsUsed(annotation.typeName)}else{markVariableAsUsed(context,annotation.typeName.name);if(annotation.typeParameters&&annotation.typeParameters.params){annotation.typeParameters.params.forEach(param=>{markTypeAnnotationAsUsed(param)})}}break}case"TSTypeLiteral":{annotation.members.forEach(member=>{if(member.typeAnnotation){markTypeAnnotationAsUsed(member.typeAnnotation)}});break}case"TSUnionType":case"TSIntersectionType":annotation.types.forEach(type=>{markTypeAnnotationAsUsed(type)});break;default:break}}function markDecoratorAsUsed(node){if(node.name){markVariableAsUsed(context,node.name);return}if(node.expression&&node.expression.name){markVariableAsUsed(context,node.expression.name);return}if(node.callee&&node.callee.name){markVariableAsUsed(context,node.callee.name)}if(node.expression&&node.expression.callee&&node.expression.callee.name){markVariableAsUsed(context,node.expression.callee.name)}}function markImplementedInterfaceAsUsed(node){if(!node||!node.id||!node.id.name){return}markVariableAsUsed(context,node.id.name);if(!node.typeParameters||!node.typeParameters.params){return}node.typeParameters.params.forEach(markTypeAnnotationAsUsed)}function markSuperClassAsUsed(node){if(!node.superClass){return}markVariableAsUsed(context,node.superClass.name);if(!node.superTypeParameters||!node.superTypeParameters.params){return}node.superTypeParameters.params.forEach(markTypeAnnotationAsUsed)}function markExtendedInterfaceAsUsed(node){if(!node||!node.id||!node.id.name){return}markVariableAsUsed(context,node.id.name);if(!node.typeParameters||!node.typeParameters.params){return}node.typeParameters.params.forEach(markTypeAnnotationAsUsed)}function markFunctionReturnTypeAsUsed(node){if(node.returnType){markTypeAnnotationAsUsed(node.returnType)}}function markClassOptionsAsUsed(node){markSuperClassAsUsed(node);if(node.implements){node.implements.forEach(markImplementedInterfaceAsUsed)}if(node.decorators){node.decorators.forEach(markDecoratorAsUsed)}}return{Identifier(node){if(node.typeAnnotation){markTypeAnnotationAsUsed(node.typeAnnotation)}if(node.decorators){node.decorators.forEach(markDecoratorAsUsed)}},TSTypeAnnotation(node){if(node.typeAnnotation){markTypeAnnotationAsUsed(node.typeAnnotation)}},FunctionDeclaration:markFunctionReturnTypeAsUsed,FunctionExpression:markFunctionReturnTypeAsUsed,ArrowFunctionExpression:markFunctionReturnTypeAsUsed,CallExpression(node){if(node.typeParameters&&node.typeParameters.params){node.typeParameters.params.forEach(markTypeAnnotationAsUsed)}},Decorator:markDecoratorAsUsed,TSInterfaceHeritage:markExtendedInterfaceAsUsed,ClassDeclaration:markClassOptionsAsUsed,ClassExpression:markClassOptionsAsUsed,ObjectPattern(node){if(node.typeAnnotation){markTypeAnnotationAsUsed(node.typeAnnotation)}},MethodDefinition(node){if(node.decorators){node.decorators.forEach(markDecoratorAsUsed)}}}}}},1702:function(module,exports,__webpack_require__){"use strict";const SENTINEL_TYPE=/^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;const FOR_IN_OF_TYPE=/^For(?:In|Of)Statement$/;function parseOptions(options){let functions=true;let classes=true;let variables=true;let typedefs=true;if(typeof options==="string"){functions=options!=="nofunc"}else if(typeof options==="object"&&options!==null){functions=options.functions!==false;classes=options.classes!==false;variables=options.variables!==false;typedefs=options.typedefs!==false}return{functions,classes,variables,typedefs}}function isFunction(variable){return variable.defs[0].type==="FunctionName"}function isOuterClass(variable,reference){return variable.defs[0].type==="ClassName"&&variable.scope.variableScope!==reference.from.variableScope}function isOuterVariable(variable,reference){return variable.defs[0].type==="Variable"&&variable.scope.variableScope!==reference.from.variableScope}function isType(variable){return variable.defs[0].type==="Variable"&&variable.defs[0].parent.kind==="type"}function isInRange(node,location){return node&&node.range[0]<=location&&location<=node.range[1]}function isInInitializer(variable,reference){if(variable.scope!==reference.from){return false}let node=variable.identifiers[0].parent;const location=reference.identifier.range[1];while(node){if(node.type==="VariableDeclarator"){if(isInRange(node.init,location)){return true}if(FOR_IN_OF_TYPE.test(node.parent.parent.type)&&isInRange(node.parent.parent.right,location)){return true}break}else if(node.type==="AssignmentPattern"){if(isInRange(node.right,location)){return true}}else if(SENTINEL_TYPE.test(node.type)){break}node=node.parent}return false}module.exports={meta:{docs:{description:"Disallow the use of variables before they are defined",category:"Variables",recommended:false,url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-use-before-define.md"},schema:[{oneOf:[{enum:["nofunc"]},{type:"object",properties:{functions:{type:"boolean"},classes:{type:"boolean"},variables:{type:"boolean"},typedefs:{type:"boolean"}},additionalProperties:false}]}]},create(context){const options=parseOptions(context.options[0]);function isForbidden(variable,reference){if(isFunction(variable)){return options.functions}if(isOuterClass(variable,reference)){return options.classes}if(isType(variable)&&!options.typedefs){return false}if(isOuterVariable(variable,reference)){return options.variables}return true}function findVariablesInScope(scope){scope.references.forEach(reference=>{const variable=reference.resolved;if(reference.init||!variable||variable.identifiers.length===0||variable.identifiers[0].range[1]<reference.identifier.range[1]&&!isInInitializer(variable,reference)||!isForbidden(variable,reference)){return}context.report({node:reference.identifier,message:"'{{name}}' was used before it was defined.",data:reference.identifier})})}function findVariables(){const scope=context.getScope();findVariablesInScope(scope)}const ruleDefinition={"Program:exit"(node){const scope=context.getScope(),ecmaFeatures=context.parserOptions.ecmaFeatures||{};findVariablesInScope(scope);if(ecmaFeatures.globalReturn||node.sourceType==="module"){findVariablesInScope(scope.childScopes[0])}}};if(context.parserOptions.ecmaVersion>=6){ruleDefinition["BlockStatement:exit"]=findVariables;ruleDefinition["SwitchStatement:exit"]=findVariables;ruleDefinition["ArrowFunctionExpression:exit"]=function(node){if(node.body.type!=="BlockStatement"){findVariables()}}}else{ruleDefinition["FunctionExpression:exit"]=findVariables;ruleDefinition["FunctionDeclaration:exit"]=findVariables;ruleDefinition["ArrowFunctionExpression:exit"]=findVariables}return ruleDefinition}}},1703:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Disallows the use of require statements except in import statements",extraDescription:[util.tslintRule("no-var-requires")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/no-var-requires.md"},schema:[]},create(context){return{CallExpression(node){if(node.callee.name==="require"&&node.parent.type==="VariableDeclarator"){context.report({node,message:"Require statement not part of import statement"})}}}}}},1704:function(module,exports,__webpack_require__){"use strict";const util=__webpack_require__(1684);module.exports={meta:{docs:{description:"Require the use of the `namespace` keyword instead of the `module` keyword to declare custom TypeScript modules.",extraDescription:[util.tslintRule("no-internal-module")],category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/prefer-namespace-keyword.md"},fixable:"code",schema:[]},create(context){const sourceCode=context.getSourceCode();function isTypeScriptModuleDeclaration(node){return node.id&&node.id.type==="Literal"}function getStartIndex(node){if(node.modifiers&&node.modifiers.length>0&&node.modifiers[0].type==="TSDeclareKeyword"){return node.range[0]+"declare".length+1}return node.range[0]}return{TSModuleDeclaration(node){const declaration=sourceCode.getText(node);if(isTypeScriptModuleDeclaration(node)||/\bnamespace\b/.test(declaration)){return}context.report({node,message:"Use 'namespace' instead of 'module' to declare custom TypeScript modules",fix(fixer){const start=getStartIndex(node);return fixer.replaceTextRange([start,start+"module".length],"namespace")}})}}}}},1705:function(module,exports,__webpack_require__){"use strict";const definition={type:"object",properties:{before:{type:"boolean"},after:{type:"boolean"}},additionalProperties:false};module.exports={meta:{docs:{description:"Require consistent spacing around type annotations",category:"TypeScript",url:"https://github.com/nzakas/eslint-plugin-typescript/blob/master/docs/rules/type-annotation-spacing.md"},fixable:"code",schema:[{type:"object",properties:{before:{type:"boolean"},after:{type:"boolean"},overrides:{type:"object",properties:{colon:definition,arrow:definition},additionalProperties:false}}}]},create(context){const punctuators=[":","=>"];const sourceCode=context.getSourceCode();const options=context.options[0]||{};const overrides=options.overrides||{};const colonOptions=Object.assign({},{before:false,after:true},options,overrides.colon);const arrowOptions=Object.assign({},{before:true,after:true},options,overrides.arrow);function checkTypeAnnotationSpacing(typeAnnotation){const nextToken=typeAnnotation;const punctuatorTokenEnd=sourceCode.getTokenBefore(nextToken);let punctuatorTokenStart=punctuatorTokenEnd;let previousToken=sourceCode.getTokenBefore(punctuatorTokenEnd);let type=punctuatorTokenEnd.value;if(punctuators.indexOf(type)===-1){return}const before=type===":"?colonOptions.before:arrowOptions.before;const after=type===":"?colonOptions.after:arrowOptions.after;if(type===":"&&previousToken.value==="?"){type="?:";punctuatorTokenStart=previousToken;previousToken=sourceCode.getTokenBefore(previousToken)}const previousDelta=punctuatorTokenStart.range[0]-previousToken.range[1];const nextDelta=nextToken.range[0]-punctuatorTokenEnd.range[1];if(after&&nextDelta===0){context.report({node:punctuatorTokenEnd,message:`Expected a space after the '${type}'`,fix(fixer){return fixer.insertTextAfter(punctuatorTokenEnd," ")}})}else if(!after&&nextDelta>0){context.report({node:punctuatorTokenEnd,message:`Unexpected space after the '${type}'`,fix(fixer){return fixer.removeRange([punctuatorTokenEnd.range[1],nextToken.range[0]])}})}if(before&&previousDelta===0){context.report({node:punctuatorTokenStart,message:`Expected a space before the '${type}'`,fix(fixer){return fixer.insertTextAfter(previousToken," ")}})}else if(!before&&previousDelta>0){context.report({node:punctuatorTokenStart,message:`Unexpected space before the '${type}'`,fix(fixer){return fixer.removeRange([previousToken.range[1],punctuatorTokenStart.range[0]])}})}}function checkFunctionReturnTypeSpacing(node){if(node.returnType){checkTypeAnnotationSpacing(node.returnType.typeAnnotation||node.returnType)}}return{Identifier(node){if(node.typeAnnotation){checkTypeAnnotationSpacing(node.typeAnnotation.typeAnnotation||node.typeAnnotation)}},TSTypeAnnotation(node){checkTypeAnnotationSpacing(node.typeAnnotation)},FunctionDeclaration:checkFunctionReturnTypeSpacing,FunctionExpression:checkFunctionReturnTypeSpacing,ArrowFunctionExpression:checkFunctionReturnTypeSpacing}}}}}]);